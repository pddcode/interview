# Masonry的布局应该放在哪里？

```
// tell UIKit that you are using AutoLayout
+ (BOOL)requiresConstraintBasedLayout {
    return YES;
}

// this is Apple's recommended place for adding/updating constraints
- (void)updateConstraints {

    // --- remake/update constraints here
    [self.button remakeConstraints:^(MASConstraintMaker *make) {
        make.width.equalTo(@(self.buttonSize.width));
        make.height.equalTo(@(self.buttonSize.height));
    }];
    
    //according to apple super should be called at end of method
    [super updateConstraints];
}

- (void)didTapButton:(UIButton *)button {
    // --- Do your changes ie change variables that affect your layout etc ---
    self.buttonSize = CGSize(200, 200);

    // tell constraints they need updating
    [self setNeedsUpdateConstraints];
}
```

# 微信分享大图如何实现，从进程的角度

# 进程间的通信

### URL Scheme
APP1通过openURL的方式调到APP2，并且在URL中带上想要的参数，有点类似HTTP个get请求进行参数传递。

### keychain
keychain用于APP间通信的一个典型的场景和APP的登录有关，就是统一账户登录平台。使用同一个账号平台的多个APP，只要其中一个APP用户进行了登录，其他APP就可以实现自动登录不需要用户多次输入账号和密码。一般开放平台都会提供登录SDK，在这个SDK内部就可以把登录相关的信息都写到keychain中，这样如果多个app都集成了这个SDK，那么就可以实现统一账户登录了。

### UIPasteboard
UIPasteboard是剪切板功能，因为iOS的原生控件UITextView，UITextField，UIWebView，我们在使用时如果长按，就会出现复制，剪切，选中，全选粘贴等功能，这个就是利用系统剪切板功能实现的，而每一个APP都可以去访问系统剪切板。
(典型的例子就是淘口令)
![](https://img-blog.csdn.net/20171225123152927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3VhbmdkYWNhaWt1YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### Airdrop

### UIactivityViewController
iOS SDK中封装好的类在APP之间发送数据，分享数据和操作数据。
![](https://img-blog.csdn.net/20171225124028961?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3VhbmdkYWNhaWt1YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20171225123930299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva3VhbmdkYWNhaWt1YW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

# 线程死锁的四个条件

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。
四个必要条件：

- 互斥：一个资源一次只能被一个线程使用
- 占有且等待：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- 不可强行占有：线程已获得的资源，在使用完之前，不能强行剥夺
- 循环等待条件：线程间形成的一种头尾相接的循环等待关系

# 如何自己设计json转model

# 一张图片的内存大小是由什么决定的

# 你知道哪些编码方式

ASCII ：用一个字节存储，总共128个，表示英语字母和字符

UTF-16：它是和Unicode相关联的，使用定长的两个字节来表示Unicode的转化格式

UTF-8：UTF-16统一采用两个字节来表示一个字符，虽然在表示上非常简单，但是也有缺点，很多字符一个字节就能表示。它采用变长。

1字节 0xxxxxxx
 
2字节 110xxxxx 10xxxxxx 

3字节 1110xxxx 10xxxxxx 10xxxxxx 

4字节 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 

5字节 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 

6字节 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 

# 队列和线程的关系

# assign可以用在对象中吗
可以修饰，但是不推荐

# isEqual和hash的关系

```
UIColor *color1 = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0];
UIColor *color2 = [UIColor colorWithRed:0.5 green:0.5 blue:0.5 alpha:1.0];
NSLog(@"color1 == color2 = %@", color1 == color2 ? @"YES" : @"NO");
NSLog(@"[color1 isEqual:color2] = %@", [color1 isEqual:color2] ? @"YES" : @"NO");
```
```
color1 == color2 = NO
[color1 isEqual:color2] = YES
```

==运算符只是简单地判断是否是同一个对象，而isEqual方法可以判断对象是否相同

为了优化判等效率，基于Hash的NSSet和NSDictionary在判断成员是否相等时，会这样做：

- 集成成员的hash值是否和目标hash值相等，如果相同则进入下一步，如果不等，直接判断不等
- hash值相同的情况下，再进行对象判等，作为判等结果

# 可变数组的实现原理

# 如何hook一个对象方法，而不影响其他对象

# 为什么要使用HTTP，而不直接用TCP？

# 如何保证HTTP传输到达

# 如何检测应用是否卡顿
time profile和RunLoop

# 拥塞控制
TCP的拥塞控制算法分三部分：慢启动，拥塞避免，快速恢复

- 慢启动：

刚开始缓慢的发送，当收到确认报文后，下一次同样的时间间隔内，将发送两倍速率的两份数据包，，所以短时间内，一个TCP链接的发送方将以指数级增长，但一旦出现丢包，即收到冗余的ACK确认，那么发送方认为网络是拥堵的。于是将速率调为1，再进行指数增长，但是有一个阈值，这个阈值是上次丢包时发送方发送速率的一半，达到该阈值就会谨慎增长，进入拥塞避免。

- 拥塞避免：

每个往返时间段发送的所有数据报全部得到确认后，下一次就增加一个分组的发送，这样缓慢的增长效率是谨慎的。那么一旦出现发送端超时丢包，注意这里是超时，将发送速率置为一并重新进入慢启动状态，阈值就是当前发送效率的一半。

- 快速恢复

收到几个冗余的ACK，TCP减半当前发送速率并就进入快恢复，即收到几个冗余的ACK就增加几个分组的发送效率

# 多态

基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。

# ping是什么协议
ICMP协议

# TCP头部多长，ip呢
都是20字节

# MTU

一种通信协议的某一层上面所能通过的最大数据包大小

# 一个进程有哪些区

堆，栈，全局区(静态区)， 常量区，程序代码区

# 传输层和网络层分别做什么的

运输层：将应用层推出套接字的所有数据收集起来，并且按照应用层指定的运输层协议，TCP或UDP，重新封装应用层数据报，并推给网络层等待发送。

# UDP可以实现一对多吗

可以实现多播。多播是基于UDP套接字传输数据的基础完成，数据包格式与前面讲到的UDP数据包相同，以前的传输数据包的地址改成多播地址。

优点是：节省网络流量，减少带宽，减少发送端重复无用的工作。

# 发送一个HTTP请求的过程

# TCP是如何保证可靠的

- 建立连接：三次握手
- 传输数据：ACK机制
由于通信过程的不可靠性，传输的数据不可避免的会出现丢死，延迟，错误，重复等各种状况，TCP协议为解决这些问题设计了一系列机制。这个机制的核心，就是发送方接收到数据后，接收方要向发送方发送ACK。如果发送方没手袋正确的ACK，就会重新发送数据直到接收到ACK为止。在不同异常情况下，ACK机制是怎么工作的：
- 数据丢失或延迟：发送方发送数据seq时会起一个定时器，如果在指定时间内没有接收到ACK seq + 1，就把数据seq再发一次。
- 数据乱序。接收方上一个收到的正确数据是seq + 4，它返回seq + 5作为ACK。这时候它收到了seq + 7，因为顺序错了，所以接收方会再次返回seq + 5给发送方
- 数据错误。每一个TCP数据都会带着数据的校验和。接收方收到数据seq + 3以后会先对校验和进行验证。如果结果不对，则发送ACK seq + 3，让发送方重新发送数据。
- 数据重复。接收方直接丢弃重复的数据即可。

# 内核态和用户态的区别
> 所有用户程序都是运行在用户态的, 但是有时候程序确实需要做一些内核态的事情, 例如从硬盘读取数据, 或者从键盘获取输入等. 而唯一可以做这些事情的就是操作系统, 所以此时程序就需要先操作系统请求以程序的名义来执行这些操作.
这时需要一个这样的机制: 用户态程序切换到内核态, 但是不能控制在内核态中执行的指令
- 内核态：CPU可以访问内存的所有数据，包括外围设备
- 用户态：只能受限的访问内存，且不能访问外围设备

# 造成网络卡顿的原因

# import和include

- 1.import会自动导入一次，不会重复导入
- 2.不会发生交叉编译，因为在Objective-c中存在c/c++和Objective-c混编的问题，如果用#include引入头文件，会导致交叉编译

- 3.<>引用系统文件，用于对系统自带的头文件的引用，编译器会在系统文件目录下去查找该文件。
- 4.“”引用用户自定义的文件，首先在用户目录下查找，
然后到安装目录下查找

# HTTP请求的起始行

包括方法，请求资源的URL，HTTP版本

# 滑动窗口

最多允许发送方有N个已发送未被确认的数据报文。当发送窗口从左到右已经连续多个报文被确认后，整个窗口将向前滑动多个单位长度。

# 2msl

因为2ms是一份报文存在于网络中的最长时间，超过该时间到达的报文都将被丢弃，而如果客户端最后的确认报文与网络中丢失的话，服务器必将发起超时请求，重新发送第三次挥手动作，此时等待中的客户端就可随即重新发送一份确认请求。

# 七层网络协议

- 物理层：将数据转化为0和1
- 数据链路层：规定0和1的分包形式
- 网络层：负责选择会话路径
- 传输层：为高层提供可靠的端到端的连接
- 会话层：建立，管理和终止表示层和实体之间的通信会话
- 表示层：解决不同系统之间的通信

# socket通信

socket是基于TCP/IP,是服务器和客户端直接使用socket套接字进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方都可以主动发送数据。一般在游戏开发或者股票开发这种要求即时性很强并且保持发送数量比较大的场合使用，主要使用CFSocketRef。


# XML的解析

SAX是是基于事件流的解析，DOM是基于XML文档树结构的解析


# SDWebImage面试题

- 1。clear和clean的区别

clear先把之前的缓存文件夹删除掉，然后新建一个文件夹

clean 先删除过期的文件，然后计算剩余缓存文件的大小，如果currentSize > maxSize，继续删除，按照它缓存文件创建的时间删除，直到currentSize <= maxSize

- 2.内存缓存时间是多久

- 3.内存缓存机制

NSCache

- 4.下载的最大并发数量

6条

- 5.SDWebImage任务的执行顺序，是怎么实现的？
先进先出和先进后出，通过依赖来实现

- 6.怎么处理图片名称
对URL进行MD5加密

- 7.使用什么来下载图片

NSURLSession配合NSURLSessionDataTask，使用代理来下载

- 8.下载的默认的超时时间是多少？
15s

- 9.框架内部对内存警告的处理方式？
监听系统发出的警告通知，然后清空内存缓存

- 10 如何计算图片的成本

长 * 缩放比例 * 宽 * 缩放比例

```
image.size.height * image.size.width * image.scale * image.scale
```

- 11 保证错误的URL不会被尝试重新下载

因为内部设置了一个黑名单

- 12 是如何识别图片类型的？

根据图片文件（NSData）十六进制数据的第一个字节判断

- 13 设置缓存的类型

```
SDImageCacheTypeNone 永不缓存，但是从网上下载
SDImageCacheTypeDisk 只缓存到磁盘上
SDImageCacheTypeMemory 只缓存到内存中
```

- 14 磁盘缓存存储的路径

在 沙盒/Library/Cache 中

# 线程间通信的方式

- 锁机制
- 信号量机制
- 信号机制

# AFNetworking源码

AF分为以下5个功能模块：

- NSURLSession：网络通信模块
- ReachAbility：网络状态监听模块
- Security：网络通信安全策略模块
- Serialization：网络通信信息序列化，反序列化模块

![1](https://user-gold-cdn.xitu.io/2017/3/6/8df8fa4b49000b40a5ec09ad04810feb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

# 使用UICollectionview实现瀑布流

- collectionViewContentSize：

计算collectionview的尺寸

- prepareLayout：

该方法发生在UICollectionview数据准备好，但是界面还未布局之时，用于计算布局信息，设置item的相关属性。

- layoutAttributesForElements：

它决定了哪些item在collectionview给定的区域可见

- layoutAttributesForItemAtindexpath:

返回每一个item的layoutAttributes

# 设计模式总结

- 装饰模式

它可以在不修改原代码的基础上进行拓展。注意，它与继承最大的区别是，继承时，子类可以修改父类的行为，而装饰模式不希望如此。

- 适配器模式

将一个类的接口转化为另一个类的接口，使得原本互不兼容的类可以通过接口一起工作。

- 备忘录模式

它在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到保存之前的状态。（我们在编程的时候，经常需要保存对象的一个状态，当需要的时候能，可以恢复到这个状态。）

- 外观模式

外观模式在复杂的业务系统上提供了简单的接口

- 观察者模式

定义对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，其相关依赖对象皆得到通知并被自动更新

- 策略模式

实现一个功能的算法有很多种，把这些算法封装起来，让他们相互独立，并暴露出相同的接口供调用，这种模式让算法的变换不会影响到使用算法的客户。

- 工厂模式

各个具体工厂重载其抽象工厂父类中定义的工厂方法并用这个重载的工厂方法创建自己的产品

# NSURLSession和NSURLConnection的区别

### 1.普通任务和上传
NSURLSession针对下载和上传等复杂的网络操作提供了专门的解决方案，针对普通，上传和下载分别对应三种不同的网络请求任务：NSURLSessionDataTask，NSURLSessionUploadTask，NSURLSessionDownloadTask，创建的task都是挂起状态，需要Resume才能执行。

### 2.下载任务方式
NSURLConnection下载文件时，先将整个文件下载到内存，然后再写入沙盒，如果文件比较大，就会出现内存暴涨的情况。而NSURLSessionDownloadTask下载文件，会默认下载到沙盒中的temp文件，不会出现内存暴涨的情况，但是在下载完成后会将temp临时文件删除。

### 3.请求方法的控制 
NSURLConnection实例化对象，实例化后默认开始，而cancel刻印停止请求的发送，停止后不能继续访问，需要创建新的请求。

NSURLSession有三个控制方法，cancel，suspend，resume，暂停后可以通过继续恢复当前的请求任务。 


### 4.断点续传
NSURLConnection使用Content-range头部，NSURLSession可以使用`cancelByProducingResumeData:`及`downloadTaskWithResumeData:`

# UIVIew的生命周期
用xib加载：

```
2017-04-15 12:33:22.194 UIViewController和UIView生命周期加载和卸载[59932:1194239] initWithCoder
2017-04-15 12:33:22.195 UIViewController和UIView生命周期加载和卸载[59932:1194239] awakeFromNib
2017-04-15 12:33:22.195 UIViewController和UIView生命周期加载和卸载[59932:1194239] willMoveToWindow
2017-04-15 12:33:22.195 UIViewController和UIView生命周期加载和卸载[59932:1194239] willMoveToSuperview
2017-04-15 12:33:22.196 UIViewController和UIView生命周期加载和卸载[59932:1194239] didMoveToWindow
2017-04-15 12:33:22.196 UIViewController和UIView生命周期加载和卸载[59932:1194239] didMoveToSuperview
2017-04-15 12:33:22.197 UIViewController和UIView生命周期加载和卸载[59932:1194239] layoutSubviews
//这里是点击移除以后
2017-04-15 12:33:25.769 UIViewController和UIView生命周期加载和卸载[59932:1194239] willMoveToSuperview
2017-04-15 12:33:25.770 UIViewController和UIView生命周期加载和卸载[59932:1194239] willMoveToWindow
2017-04-15 12:33:25.771 UIViewController和UIView生命周期加载和卸载[59932:1194239] didMoveToWindow
2017-04-15 12:33:25.771 UIViewController和UIView生命周期加载和卸载[59932:1194239] didMoveToSuperview
2017-04-15 12:33:25.771 UIViewController和UIView生命周期加载和卸载[59932:1194239] dealloc
```

使用代码加载：

```
2017-04-15 12:38:57.562 UIViewController和UIView生命周期加载和卸载[60323:1208772] initWithFrame
2017-04-15 12:38:57.562 UIViewController和UIView生命周期加载和卸载[60323:1208772] init
2017-04-15 12:38:57.562 UIViewController和UIView生命周期加载和卸载[60323:1208772] willMoveToWindow
2017-04-15 12:38:57.563 UIViewController和UIView生命周期加载和卸载[60323:1208772] willMoveToSuperview
2017-04-15 12:38:57.563 UIViewController和UIView生命周期加载和卸载[60323:1208772] didMoveToWindow
2017-04-15 12:38:57.563 UIViewController和UIView生命周期加载和卸载[60323:1208772] didMoveToSuperview
2017-04-15 12:38:57.564 UIViewController和UIView生命周期加载和卸载[60323:1208772] layoutSubviews
//点击移除以后
2017-04-15 12:39:02.751 UIViewController和UIView生命周期加载和卸载[60323:1208772] willMoveToSuperview
2017-04-15 12:39:02.752 UIViewController和UIView生命周期加载和卸载[60323:1208772] willMoveToWindow
2017-04-15 12:39:02.752 UIViewController和UIView生命周期加载和卸载[60323:1208772] didMoveToWindow
2017-04-15 12:39:02.752 UIViewController和UIView生命周期加载和卸载[60323:1208772] didMoveToSuperview
2017-04-15 12:39:02.752 UIViewController和UIView生命周期加载和卸载[60323:1208772] 点击移除
2017-04-15 12:39:02.753 UIViewController和UIView生命周期加载和卸载[60323:1208772] dealloc
```

# 数组和链表的区别
数组静态分配内存，链表静态分配内存

数组在内存中连续，链表不连续

数组元素在栈区，链表元素在堆区

数组利用下标定位，时间复杂度为O(1),链表定位元素时间复杂度为O(n)

数组插入和删除元素的时间复杂度是O(n),链表的时间复杂度是O(1)

# 如果页面A跳转到页面B，A的viewDidDisappear方法和B的 viewDidAppear方法哪个先调用？

```
A页面-(void)viewWillDisappear:(BOOL)animated
B页面 -(void)viewWillAppear:(BOOL)animated
A页面-(void)viewDidDisappear:(BOOL)animated
B页面-(void)viewDidAppear:(BOOL)animated

```

# SDWebImage下载了图片为什么要解码？

图片分为矢量图和位图，显示到屏幕中的是位图图像，位图图片格式有RGB，CMYK等颜色模式，其中RGB是最常见的颜色模式，它通过R，G，B三个颜色通道的数值表示颜色。

在项目中，通常使用的是JPG或PNG压缩格式，他们是经过编码压缩后的图片格式，而图片显示到屏幕之前，需要将JPG或PNG格式的图片解码成位图图像，这个解码工作是比较耗时的，而且不能使用GPU硬解码，只能使用CPU软解码实现。

iOS默认会在UI主线程对图像进行解码，解码后的图像大小和图片的宽高像素有关。

优化解码耗时的思路是，将耗时的解码工作放在子线程中完成。SDWebImage和FastImageCache就是这么做的。具体的解码工作就是SDWebImageDecoder负责的。

# 如何判断cell显示在当前屏幕上

```
1.  - (NSArray*)visibleCells;
//UITableView的方法，这个最直接，返回一个UITableviewcell的数组。
对于自定制的cell，之后的处理可能稍微繁琐些。
```
```
2.- (NSArray*)indexPathsForVisibleRows;
//UITableview的又一个方法，这个比较好用了，返回一个NSIndexPath的数组,可以直接用indexpath.row去调你的table_related_Array里的数据了。比较方便用于自定制的cell。
```

# cookie和session的区别

session用于区分会话和不同用户的访问

- 1.session在服务器 ，Cookie在客户端
- 2.session默认存储在服务器的一个文件里
- 3.session的运行依赖于session id，而session id是存在Cookie中的，也就是说，如果浏览器禁用了Cookie，同时session也会失效
- 4.用户验证这种场合一般会用session。


# block中的copy是深拷贝还是浅拷贝？

1.NSGlobalBlock没有copy行为，copy后无任何变化

2.从NSStackBlock到NSMallocBlock，copy后内存是新地址，类似深拷贝

3.从NSMallocBlock到NSMallocBlock，copy后内存不变，只是引用计数加一，类似浅拷贝

在大多数情况下，编译器会自动进行判断，对栈上的block复制到堆上，但是还有一些特殊的情况，编译器不能进行判断，即：

- 向方法或函数的参数中传递了Block时

但是下列情况还是不用手动复制：

- cocoa框架中使用了含有usingBlock等时
- gcd的API





Block从栈复制到堆时对Block变量产生的影响

|__block变量的存储域|Block从栈复制到堆时产生的影响|
|---|---|
|栈|从栈复制到堆并被Block持有|
|堆|被Block持有，引用计数加一|

栈上的__block结构体实例在__block变量从栈复制到堆上时，会将成员变量forwarding的值替换为复制目标堆上的__block结构体的地址。

当Block从栈区复制到堆区时，封装age的结构体也会复制一份到堆区，这个时候其实block结构体内部age指针还是指向栈区的age结构体，那这样的话无论如何都无法取得栈区的age结构体。Apple显然想到了这个问题，在age结构体从栈区复制到堆区的过程中，内部将栈区的age结构体的_forwarding指针修改了，改为指向堆区的age结构体，这样一来，我们再通过block结构体访问age指针时，访问到了栈区的age结构体，然后通过栈区的age结构体的_forwarding指针去访问堆区的age结构体，也就是age->_forwarding->age

什么时候栈上的Block会复制到堆上？

- 调用Block的copy实例方法时
- Block作为函数返回值返回时
- 将Block赋值给附有_strong修饰符的id类型的类或Block类型的成员变量时
- 在方法名中含有usingBlock和GCD的API时。

如果Block是在栈上，将不会对auto变量产生强引用，如果是在堆上，将根据是使用的strong还是weak修饰来决定是否对block产生强引用

###计算机系统中CPU，GPU，显示器协同工作的方式
博客地址：[https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/](https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/)
#####首先说一下屏幕显示图像的原理
![图像显示](https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png)
>首先从过去的CRT显示器原理说起，CRT的电子枪按照上面的方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号，简称HSync,而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号，简称VSync。显示器通常以固定频率进行刷新，这个频率就是VSync信号产生的频率。

![](https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png)
CPU计算好显示内容提交到GPU，GPU渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照VSync信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。
###卡顿产生的原因
![](https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png)
>在VSync信号到来后，系统图形服务会通过CADisplayLink等机制通知App，App主线程开始在CPU中计算显示内容，比如视图的创建，布局计算，图片解码，文本绘制等。随后CPU会将计算好的内容提交到GPU去，由GPU进行变换，合成，渲染。随后GPU会把渲染结果提交到帧缓冲区去，等待下一次VSync信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个VSync时间内，CPU或者GPU没有完成内容提交哦啊，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。

从上图中可以看出，CPU和GPU不论哪个阻碍了显示流程，都会造成掉帧现象。
###drawRect内存恶魔
先说一下iOS程序中图形显示的原理，在iOS系统中所有显示的视图都是从基类UIView继承而来，同时uiview负责接收用户交互。但是实际上你所看到的视图内容，包括图形等，都是由UIView的一个实例图层属性来绘制和渲染的，那就是CALayer。

在每一个uiview实例中，都有一个默认的支持图层，uiview负责创建并管理这个图层。实际上这个CALayer图层才是真正用来显示在屏幕上的。

但是CALayer其实也是iOS中的一个普通的类，它并不能直接渲染到屏幕上，因为屏幕上看到的东西，其实都是一张张图片。而为什么我们能看到CALayer的内容呢？是因为CALayer内部有一个contents属性，contents默认可以传一个id类型的对象，但是只有你传CGImage的时候，它才能正常显示在屏幕上。所以最终我们的图形渲染落点落在contents身上如图：
![](https://img-blog.csdn.net/20160108093944851?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

contents也被称为寄宿图，除了给他赋值CGImage之外，我们也可以直接对他进行绘制，通过继承uiview的drawRect方法即可自定义绘制。drawRect方法没有默认的实现，因为对UIview来说，寄宿图不是必须的，UIView不关心绘制的内容。如果UIView检测到drawRect方法被调用了，他就会为视图分配一个寄宿图，哲哥寄宿图的像素尺寸等于视图大小乘以contentsscale，占用的内存为:

> 图层宽****图层高****4字节

既然使用drawRect结合Core graphics画图这么容易造成内存问题，那么我们怎么去优化呢？
> 最合理的办法处理类似于画板这样画线条的需求直接用专用图层CAShapeLayer
> CAShapelayer是一个通过矢量图形而不是通过位图来绘制的图层子类，用CGPath来定义想要绘制的图形，CAShapelayer会自动渲染，对比之下CAShapelayer有以下优点：
>
>- 1.渲染快速，CAShapelayer使用硬件加速，绘制统一图形会比用Core graphics快很多
>- 2.高效使用内存，一个CAShapelayer不需要像普通CALayer应用创建一个寄宿图形，所以无论有多大，都不会占用太大的内存。

### 适配器模式
适配器模式是用在比如有一个工具类，现在想使用这个工具类，但是这个类的接口不是我们想要的类型，但是为了复用，又不能改变这个接口，所以就需要创建一个适配器类，在客户端写代理方法，让适配器类去遵循这个代理方法并实现它，在适配器类的代理方法里面去调用这个工具类。

### 装饰模式
即为一个类增加功能但是却不改变类原有的功能
在iOS中可以通过继承和category来实现

### 策略模式
策略模式把具体的算法封装到了具体策略角色内部，增强了可扩展性，隐蔽了实现细节，避免了if- else这种不易维护的条件语句
[https://www.runoob.com/design-pattern/strategy-pattern.html](https://www.runoob.com/design-pattern/strategy-pattern.html)

### 工厂方法模式
定义创建对象的接口，让子类决定实例化哪一个接口。
[https://www.runoob.com/design-pattern/factory-pattern.html](https://www.runoob.com/design-pattern/factory-pattern.html)

### KVC

### 红黑树
> 红黑树是一颗二叉排序树，它在每个结点上增加了一个存储位来表示节点的颜色，可以是red或black。通过对任一条从根结点到叶子结点的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其它路径长两倍，因此是近乎平衡的。

一颗红黑树四具有如下性质的二叉排序树：
- 每个结点的颜色只能是红色或黑色。
- 根节点是黑色
- 每个叶子结点（NIL）是黑色
- 如果一个结点是红色，那么它的两个子节点都是黑色
- 对每个结点，从该结点到其所有后代叶子结点的简单路径上，均包含相同数目的黑色结点
![红黑树](https://user-gold-cdn.xitu.io/2017/4/17/94f477cf946e99867d0c8ca7f9c5966e?imageView2/0/w/1280/h/960)

### 二叉搜索树
##### 二叉搜索树的查找
> 可以从根节点开始查找，和根节点的值作比较，比根节点的值小，就字根节点的左子树中查找，比根节点的值大，舅子根节点的右子树中查找。以此出发，递归算法。这样每次查找，树都会砍掉一半，近乎折半查找。

遍历打印可以用**中序遍历**，打印出从小到大的有序数组。

##### 二叉搜索树的插入
> 要么当树为空时直接插入作为根节点，要么当树为非空时，新节点作为查找路径终止结点额左孩子或者右孩子插入。这种插入不需要移动树的结点

##### 二叉搜索树的删除
> 分三种情况，删除的结点只有左子树，删除的结点只有右子树，删除的结点有左子树又有右子树。如果只有左子树或者只有右子树，那么就直接将左子树或者右子树替换被删除的结点即可。如果既有左子树又有右子树，如下图
![](https://user-gold-cdn.xitu.io/2017/4/17/bbccdcc323fdcc30817744869a22c53a?imageslim)

那么就用**要删除结点的前驱结点**来代替它，比如这里就用39这个结点来代替45

- 二叉搜索树的优点在于插入删除都不用移动元素，只需要修改指针，在查找上，查找次数等于待查找的结点在二叉排序树的层级。

当出现极端情况时：
![](https://user-gold-cdn.xitu.io/2017/4/17/438e796c95cf4957119563d5fafbbbbd?imageView2/0/w/1280/h/960)
查找需要的次数太多，所以引出了二叉平衡树AVL和红黑树。

##### 二叉平衡树（AVL树）
二叉平衡树是一种二叉搜索树，其中每个结点的左子树和右子树的高度差不超过1.

二叉平衡树就是二叉树的构建过程中，每当插入一个结点，看是不是因为树的插入破坏了树的平衡性，若是，则找出最小不平衡树，在保持二叉树特性的前提下，调整最小不平衡树中各个结点之间的链接关系，进行相应的旋转，使之成为新的平衡树。
![](https://user-gold-cdn.xitu.io/2017/4/17/7c6408fb4f07a66d38c6d6d1e1d4e531?imageView2/0/w/1280/h/960)
左旋和优选的过程我们可以看到平衡因子从(0, 1, 2)变为(0, 0, 0),即是一种将非平衡状态转换为平衡状态的过程，这也是AVL树不不调整的核心。

##### 平衡二叉树不会出现像二叉搜索树那样查找的最差情况，但是其删除和插入的效率很低，因此就有了红黑树的出现。
##### 最小不平衡子树 指离插入节点最近且以平衡因子的绝对值大于1的节点作为根的子树。

AVL树的应用：AVL树的应用不多，Windows对进程地址空间的管理用到了这个AVL树，在查找数据的时候可以在logn的时间复杂度内查找数据
红黑树：c++的STL(标准模板库)中，map和set都是用红黑树实现的
链表：火车
栈：UINavigationController的栈
队列：nsoperationqueue的队列
二叉树再排序、查找、大规模数据索引方面有很多很多应用

### 排序算法
> 稳定性：a原来在b的前面，排序之后，a仍然在b的前面
##### 冒泡排序
冒泡排序是稳定的，时间复杂度是n*n,空间复杂度是1
优化方向：
若在某一趟排序中未发现气泡位置的交换，则说明待排序的无序区中所有气泡均满足轻者在上，重者在下的原则，因此，冒泡刨铣过程中可在此趟排序后终止。因此可以引入一个标签tag，在每趟排序开始前，先将其置为0，若排序过程中发生了交换，则将其置为1。

##### 选择排序
选择排序是不稳定的，时间复杂度是n*n，空间复杂度是1.
优化方向：在每一次查找最小值的时候，也可以找到最大值，然后将两者分别放在他们该出现的位置。

##### 插入排序
插入排序是稳定的，时间复杂度是n*n，空间复杂度是1
优化方向：

##### 快速排序
不稳定，时间复杂度n*logn，空间复杂度nlognn
优化方向:**三平均分区法**， 即选用待排序数组最左边，最右边和最中间的三个元素的中间值作为中轴，通过比较选出其中的中值。取这三个值的好处是在实际问题中，出现近似顺序数据 或者逆序数据的概率比较大，此时中间数据必然成为中值，这也是事实上的近似中值。

##### 归并排序
将已经有序的子序列合并，得到完全有序的序列
时间复杂度是nlogn，空间复杂度是n
优化方向：归并排序是稳定的，时间复杂度是稳定的nlogn，占用内存比较大

### HTTP请求的常见的首部字段
##### 请求首部字段
- Accept：用户代理可处理的媒体类型
- Accept-Charset：优先的字符集
- Accept-encoding：优先的内容编码
- Accept-language：优先的语言
- Authorization：认证信息
- From：用户邮箱
- Host：请求资源所在服务器
- if-match：比较实体标记(ETag) 服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。
- if-Modified-Since：比较资源的更新时间 它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。
- if-None-Match：和if-match相反
- User-Agent：客户端程序信息

##### 实体首部字段
- Allow：资源可支持的HTTP方法
- Content-Encoding：实体适用的编码方式
- Content-Language：实体主题的自然语言
- Content-Length：实体主体的大小
- Content-MD5：实体主体的摘要
- Content-Type：实体主体的媒体类型
- Expires：实体过期时间
- Last Modified


##### 为Cookie服务的首部字段
- set-cookie：响应首部字段，告诉客户端下次设置这个Cookie
- Cookie：请求首部字段，请求的时候捎上，让服务端知道自己的身份

### Cookie
> HTTP Cookie是服务器发送到用户浏览器并保存到本地的一个数据，它会字浏览器下次向同一服务器再发起请求时被携带并发送到服务器。

Cookie的主要作用在以下几个方面：
- 会话状态管理，如用户登录状态，购物车等
- 个性化设置，如用户自定义设置，主题等
- 浏览器行为跟踪

当服务器收到HTTP请求时，服务器可以在响应头里面添加一个set-Cookie选项，浏览器收到响应后通常会保存下Cookie，之后会对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器。

Cookie的secure和HTTPonly：标记为secure的Cookie只应通过被HTTP协议加密过的请求发送给服务器端。
Cookie的作用域：Domain和path标识了Cookie的作用域，即Cookie应该发送给哪些URL
Cookie可以设置过期时间，域，路径，适用站点，有效期

### session cookie的区别
- session在服务端，Cookie在客户端
- session依赖于session id，session id存储在Cookie中，所以如果禁用了Cookie，session也不能使用
- Cookie用来跟踪会话，也可以保存用户喜好或者保存用户密码
- session用来跟踪会话
session cookie针对某一次会话而言，会话结束session cookie也就随着消失了，而persistent cookie只是存在于客户端硬盘上的一段文本（通常是加密的），而且可能会遭到cookie欺骗以及针对cookie的跨站脚本攻击，自然不如 session cookie安全了。


### HTTP 缓存
[HTTP 缓存](https://www.cnblogs.com/chenqf/p/6386163.html)
根据是否要重新向服务器发起请求，可以分为两大类，即**强制缓存**和**对比缓存**
基于强制缓存的流程：
![](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210135521072-1812985836.png)
基于对比缓存的流程：
![](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141716838-764535017.png)
##### 强制缓存
强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存有没有失效呢？在没有缓存的时候，浏览器会向服务器请求数据，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header里，**cache-control**这个字段：
- private：客户端可以缓存
- public：客户端和代理服务器都可以缓存
- max-age=xxx：缓存的内容在XXX秒后失效
- no-cache：需要使用对比缓存来验证缓存数据
- no-store：所有内容都不会缓存，强制缓存，对比缓存都不会触发
##### 对比缓存
第二次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

对于对比缓存来说，缓存标识的传递是在请求header和响应header之间传递的，前面是响应header，后面是响应header
Last-modified/If-Modified-Since：服务器在响应请求时，告诉浏览器资源的最后修改时间
Etag、If-None-Match：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识

###HTTP常见状态码
- 200 OK
- 301 Moved permanebtly
- 302 Found 临时性重定向
- 304 Not Modified 服务端资源未改变，可直接使用客户端未过期的缓存
- 400 bad request 请求报文存在语法错误
- 401 Unauthorized 需要经过认证或认证失败
- 403 Forbidden 访问资源被服务器拒绝了
- 404 Not Found 服务器上没有请求的资源
- 500 internal Server Error 服务器错误

### UIView设置圆角的问题
##### 普通UIView
UIVIew的contents无内容可以直接通过设置CornerRadius达到效果，但是如果特殊情况需要设置layer.maskToBounds，那么就不要通过CornerRadius方式，可以给UIView创建一个category，使用core graphics，自己画一个圆角矩形，导出为UIimage，然后把这个UIImage使用UIImageVIew，插入UIView的视图层级的底部
```
@implementation UIView (Corner)

- (void)dlj_addRounderCornerWithRadius:(CGFloat)radius size:(CGSize)size
{
    UIGraphicsBeginImageContextWithOptions(size, NO, 0);
    CGContextRef cxt = UIGraphicsGetCurrentContext();
    
    CGContextSetFillColorWithColor(cxt, [UIColor redColor].CGColor);
    CGContextSetStrokeColorWithColor(cxt, [UIColor redColor].CGColor);
    
    CGContextMoveToPoint(cxt, size.width, size.height-radius);
    CGContextAddArcToPoint(cxt, size.width, size.height, size.width-radius, size.height, radius);//右下角
    CGContextAddArcToPoint(cxt, 0, size.height, 0, size.height-radius, radius);//左下角
    CGContextAddArcToPoint(cxt, 0, 0, radius, 0, radius);//左上角
    CGContextAddArcToPoint(cxt, size.width, 0, size.width, radius, radius);//右上角
    CGContextClosePath(cxt);
    CGContextDrawPath(cxt, kCGPathFillStroke);
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, size.width, size.height)];
    [imageView setImage:image];

    [self insertSubview:imageView atIndex:0];
}

@end
```

##### UIIMageView
为UIImageView添加圆角是直接截取图片
```
@implementation UIImage (ImageRoundedCorner)

- (UIImage*)imageAddCornerWithRadius:(CGFloat)radius andSize:(CGSize)size{
    CGRect rect = CGRectMake(0, 0, size.width, size.height);
    
    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    UIBezierPath * path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:UIRectCornerAllCorners cornerRadii:CGSizeMake(radius, radius)];
    CGContextAddPath(ctx,path.CGPath);
    CGContextClip(ctx);
    [self drawInRect:rect];
    CGContextDrawPath(ctx, kCGPathFillStroke);
    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return newImage;
}
```

### 进程间的通信
[https://www.jianshu.com/p/c1015f5ffa74](https://www.jianshu.com/p/c1015f5ffa74)
> 每个进程各有一个不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓存区，进程1把数据从用户空间拷到内核缓存区，进程2再从内核缓存区把数据读走，内核提供的这种机制叫进程间通信（IPC）

##### 管道
> 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。

![](https://upload-images.jianshu.io/upload_images/1281379-05378521a7b41af4.png)
管道的限制：
- 管道是半双工的，数据只能向一个方向流动。
- 只能用于父子进程或者兄弟进程之间。

##### 信号
> 信号是Linux系统中用于进程间相互通信或操作的一种机制，信号可以再任何时候发给某一进程，而无需知道该进程的状态。信号可以在用户空间和内核之间直接交互。

> 如果该进程当前处于未执行状态，则该信号就有内核保护起来，直到该进程恢复执行并传递给它为止。

```
Linux系统中常用信号：
（1）SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
（2）SIGINT：程序终止信号。程序运行过程中，按Ctrl+C键将产生该信号。
（3）SIGQUIT：程序退出信号。程序运行过程中，按Ctrl+\\键将产生该信号。
（4）SIGBUS和SIGSEGV：进程访问非法地址。
（5）SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。
（6）SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。
（7）SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。
（8）SIGALRM：定时器信号。
（9）SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。
```

##### 消息队列
> 消息队列是存放在内核中的消息链表，管道和消息队列的通信数据都是先进先出的原则。

##### 共享内存
> **使得多个进程可以直接读写同一块内存空间**，是最快的IPC形式。
> 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提升效率。
> 由于多个进程共享一块内存，因此需要依赖某种同步机制（如信号量）来达到进程间的同步及互斥。

##### 信号量
> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。




























